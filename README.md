# ACTIVIDADES INTELIGENCIA ARTIFICIAL
#### Alumno: Edgar Daniel Martínez Morales / Numero de control: 19121051

---

# Ensayo del libro "Inteligencia Artificial: Un Enfoque Moderno"

En este ensayo, exploraremos los capítulos 1, 2, 26 y 27122 del libro "Inteligencia artificial: un enfoque moderno". Estos capítulos desentrañan conceptos esenciales, desde la definición de la IA hasta su fascinante trayectoria histórica.

La inteligencia artificial ha experimentado un notable crecimiento desde sus inicios, generando una multitud de preguntas, inquietudes y opiniones diversas. El campo de la inteligencia artificial, o IA, no intenta solo comprender (como nosotros los humanos), sino que también se esfuerza en construir entidades inteligentes. La IA puede ser considerada como algo "universal" ya que se aplica en diferentes subcampos donde sintetiza y automatiza las tareas, debido a esto, la IA aún tiene muchas brechas donde se tiene que trabajar.
La IA se ha tratado de ver mediante 4 conceptos diferentes los cuales son _procesos mentales y razonamiento_, _la conducta_, _forma de actuar de los humanos_, _concepto ideal de inteligencia_.

La prueba de Turing se diseñó para proporcionar una definición operacional y satisfactoria de inteligencia. Turing propuso que si al conversar con una máquina un evaluador humano, no puede detectar si está hablando con un humano o una máquina (computadora), ésta pasa la prueba y se determina que es “inteligente”. Para programar un computador que supere esta prueba, es demasiado complejo hoy en día, ya que requiere de muchos factores como son: que entienda el lenguaje humano, que tenga una representación del conocimiento para almacenar lo que se conoce o se siente, que razone de manera autónoma para que pueda sacar nuevas conclusiones y respuestas por sí solo en base a la información que tiene, finalmente, que pueda aprender automáticamente y se adapte a nuevas circunstancias, además la máquina también debe poder manipular y mover objetos y percibir objetos, es decir, tener visión.

En el libro se hablan de distintos conceptos como es el teorema de incompletitud la cual dice que hay afirmaciones matemáticas que son ciertas, pero no pueden demostrarse como verdaderas o falsas dentro del sistema en el que se formulan.

Existen diversos conceptos que contemplar para decir que una máquina o agente puede comportarse como un humano, primeramente, tenemos el concepto de **_dualismo_** que no es otra cosa que una parte de la mente/alma/espíritu, que está al margen de la naturaleza y no es afectada por las leyes de la física, en cambio, el **_materialismo_** es lo que considera las operaciones del cerebro que se llevan a cabo de acuerdo con las leyes de la física.
El movimiento **_empírico_** se trata de que no puede existir algo en nuestras mentes sin antes haber pasado por nuestros sentidos, después se propuso el principio de **_inducción_** que no es más que obtenemos una conclusión mediante la exposición a asociaciones repetidas o eventos. Hubo una doctrina que se desarrolló, el **_positivismo lógico_**, la cual sostiene que el conocimiento se basa en teorías lógicas relacionadas mediante **_sentencias de observación_**.
Por otro lado, está la **_teoría de la confirmación_** la cual dice que el conocimiento se obtiene mediante las experiencias. Esta teoría fue la primera que se tomó en cuenta debido a que mostraba la mente como un proceso computacional.
La **_teoría de decisión_** es una combinación de probabilidad con la utilidad, esto se basa en tomar una decisión para llegar a un beneficio deseado, partiendo de esto, también existe la teoría de juegos, donde se tiene un agente que racionalmente debe tomar una decisión lo hace de manera aleatoria o aparentemente lo hace, debido a que debe tomar una decisión frente a otros agentes racionales que lo haga distinto.

En este capítulo, se expondrá cómo se puede extender el concepto de racionalidad para abarcar una diversidad de agentes que funcionan en cualquier entorno imaginable. Los autores emplean este concepto como base para elaborar un conjunto de principios de diseño destinados a la construcción de agentes prácticos, es decir, sistemas que puedan ser caracterizados como inteligentes de manera razonable. En esencia, se explora la aplicación del concepto de racionalidad a diversos agentes, ya sean máquinas o sistemas, que operan en entornos variados. La premisa central es que estos agentes deben tomar decisiones y actuar de manera inteligente y lógica para lograr eficazmente sus objetivos. La racionalidad, por lo tanto, se presenta como un enfoque para desarrollar máquinas o sistemas que sean percibidos como inteligentes y competentes en la toma de decisiones.

El libro dice que un agente es básicamente cualquier cosa que pueda ver lo que pasa a su alrededor con sensores y hacer algo en respuesta con actuadores. Para que un agente sea listo, necesita tener un lugar donde hacer sus movidas y pensar. En el libro, explican dos cosas importantes: la percepción, que es como el agente recibe información en cualquier momento, y la secuencia de percepciones, que es básicamente el historial de todo lo que el agente ha visto. Todos estos conceptos tienen que ver con los agentes, pero eso no significa que el agente sea necesariamente listo.
Tambien se presenta un ejemplo de una aspiradora que va limpiando la suciedad. La aspiradora sabe en qué parte está y si existe suciedad ahí, y puede decidir si limpia, se mueve a un lado u otro, o si no hace nada. Pero esto no quiere decir que la aspiradora sea lista o inteligente, porque podría estar limpiando sin parar solo moviendo la suciedad de un lado a otro, o tardarse semanas en limpiar un cuarto.

El concepto de agente racional, es decir aquel agente en el cual hace lo correcto y de la manera mas optima para poder obtener el mejor resultado posible y para poder lograr esto el libro nos presenta unas las medidas de rendimiento que nos sirven para poder medir de alguna manera el éxito.

Las medidas de rendimiento son como las reglas que definen si un agente está haciendo bien las cosas. Cuando un agente realiza acciones, provoca que su entorno pase por distintos estados. Si la secuencia de estados es la que queríamos, entonces el agente actuó correctamente. Es clave definir correctamente la medida de rendimiento de cada agente para lograr la secuencia de estados deseada. Tomando el ejemplo de la aspiradora del libro, podríamos establecer como medida de rendimiento que termine de limpiar una zona en un par de horas, algo que solo un agente racional lograría. El libro dice algo interesante: _"Como regla general, es mejor diseñar medidas de utilidad de acuerdo con lo que se quiere para el entorno, más que de acuerdo con cómo se cree que el agente debe comportarse."_ Esto me hace pensar en experiencias en mi carrera universitaria, donde a menudo los profesores quieren las cosas exactamente como ellos lo piden, sin importar si las medidas de rendimiento son las más adecuadas. Es como el dicho _"No sé cómo funciona, pero funciona"_, que refleja malas prácticas de programación cuando no se tienen buenas medidas de rendimiento.

Aquí principalmente se discute sobre lo que significa pensar y si las maquinas deberían de hacerlo o no.  
Se habla sobre dos hipótesis, la primera habla sobre la IA débil que habla sobre la afirmación de que es posible que la maquinas actúen con inteligencia y por otro lado tenemos el libro nos presenta la hipótesis de IA fuerte la cual consiste en la afirmación de que las maquinas si piensan realmente y no solo simulan una inteligencia. La realidad esta mas acercada con la IA débil ya que las maquinas están hechas para hacer trabajos específicos y solo siguen instrucciones que si se hacen en una secuencia correcta parece que la maquina piensa con verdadera inteligencia.

¿Pueden las máquinas pensar? Para explorar esta interrogante, se utiliza el ejemplo de dos preguntas interesantes. La primera, ¿pueden volar las máquinas? La respuesta es afirmativa, considerando la existencia de diversos dispositivos como aviones, drones y helicópteros. Sin embargo, la pregunta más interesante que surge a continuación es: ¿pueden nadar las máquinas? La respuesta inicial podría ser sí, pensando en barcos y submarinos. Sin embargo, la definición de nadar nos lleva a reflexionar ya que formalmente significa: _"moverse por el agua mediante el movimiento de las partes del cuerpo"_. Esto plantea la idea de que, si bien las máquinas pueden desplazarse en el agua, no cumplen con la acción específica de nadar, ya que carecen del movimiento de partes del cuerpo.

También se abordan los riesgos asociados con la inteligencia artificial, planteando la pregunta crucial de si deberíamos continuar con su desarrollo, dado que conlleva diversas amenazas. En el libro se mencionan seis de estos peligros de manera específica. El primero, que ya experimentamos, es la posible pérdida de empleos debido a la automatización. Aunque para algunos esto se presenta como oportunidades más que amenazas, es un cambio significativo. Otro aspecto que requiere atención es la posibilidad de que el uso de sistemas de IA conduzca a la pérdida de responsabilidad, especialmente cuando se emplea para tomar decisiones críticas de vida o muerte.
Entre las amenazas más significativas se encuentra la idea de que el éxito de la IA podría llevar al declive de la raza humana. La creciente convergencia entre la tecnología y las visiones futuristas de la ciencia ficción plantea preguntas fundamentales sobre si el avance descontrolado de la IA podría tener consecuencias graves para la humanidad. Este aspecto nos lleva a cuestionarnos si realmente deberíamos continuar impulsando el desarrollo de la inteligencia artificial, dada la magnitud de estas amenazas y sus posibles implicaciones para nuestro futuro.

Uno de los mayores desafíos que enfrentó la inteligencia artificial (IA) fue la capacidad de las máquinas para interactuar con su entorno, inicialmente dependiendo de las entradas proporcionadas por humanos para interpretar las salidas. Sin embargo, con los avances tecnológicos actuales, esta limitación ya no representa un problema significativo. La interacción con el mundo físico ha dejado de ser un punto débil en la IA, superándose varias barreras tecnológicas en el proceso.

Un componente vital para un agente inteligente es su capacidad para seguir el estado del mundo, lo cual involucra tanto la percepción como la actualización de las representaciones internas. Aunque los avances en la lógica proposicional y de primer orden, junto con algoritmos para entornos inciertos, han mejorado el seguimiento del mundo, la percepción real, a menudo imperfecta, sigue siendo un desafío. La combinación de probabilidad y lógica de primer orden emerge como una solución prometedora para rastrear entornos complejos y abordar la incertidumbre en la identificación de objetos.

Actualmente se plantea la pregunta de si estamos llevando la inteligencia artificial en una dirección adecuada. La respuesta breve es _"No, pero por ahora estamos bien"_. Se exploran diversas perspectivas, desde la búsqueda de la racionalidad perfecta hasta la _"racionalidad calculadora"_ y la racionalidad limitada. La **_"optimalidad limitada"_** se presenta como una opción práctica y adaptable a entornos reales, destacando un enfoque realista para el desarrollo de agentes inteligentes.
El progreso vertiginoso de la IA trae consigo oportunidades y desafíos cada vez más complejos. Aunque ha demostrado su superioridad en áreas como la automatización de procesos y la asistencia en la toma de decisiones, también plantea dilemas económicos y laborales, especialmente en la posible automatización de empleos.
En resumen, el impacto de la IA dependerá de cómo se utilice y regule. La responsabilidad recae en investigadores y desarrolladores para garantizar que la IA tenga un impacto positivo en la sociedad, recordando la sabia observación de Turing: _"Todavía queda mucho por hacer"_.

Cuando se va a comparar algoritmos para ver la rapidez de ejecución y la cantidad de memoria que requieren. Existen dos técnicas para llevar a cabo esta tarea. La primera son las **_pruebas de evaluación (benchmarking)_**, esto se refiere a ejecutar el algoritmo en un computador y medir la velocidad en segundos y el consumo de memoria en bytes ya que es lo que importa principalmente, aunque puede que no sea la mejor forma de medir algo, ya que es tan específica porque mide el rendimiento de un algoritmo en un computador, compilador y entrada de datos especifico de un lenguaje de programación y esto hace que al tener los resultados es difícil predecir como se comportara el algoritmo en un entorno diferente.
El segundo enfoque depende del análisis de algoritmos, este es más independiente de la implementación y los datos de entrada.

Una probabilidad es una medida sobre un conjunto de eventos. Un **modelo probabilístico** consiste de un espacio muestral de resultados posibles mutuamente excluyentes, así como de una medida de probabilidad para cada uno de estos resultados.
El **teorema de límite central**, dice que la media de _n_ variables aleatorias tiende a tener una distribución normal conforme _n_ tiende al infinito. Esto es para todas las variables aleatorias a menos que la varianza de cualquier subconjunto finito de variables domine a las otras.

---

# Ensayo sobre el video "Inteligencia Artificial – IBM". Presentado por Discovery Latinoamérica

Este ensayo aborda diversos aspectos relacionados con la inteligencia artificial, incluyendo consideraciones éticas sobre su desarrollo, inquietudes acerca de la posibilidad de que las máquinas superen la inteligencia humana, así como los beneficios de la IA en sectores como la salud, la accesibilidad y la competitividad en diferentes campos. Un punto particularmente interesante se centra en cómo la IA aborda temas de investigación, destacando la capacidad de las máquinas para realizar tareas que podrían resultar imposibles o difíciles para los seres humanos. El ensayo también explora la preocupación por la privacidad de las personas en el contexto de la IA, planteando la pregunta de si realmente disfrutamos de privacidad en la actualidad. Además, se destaca la fusión entre humanos y máquinas, un tema que anteriormente se consideraba más propio de la ciencia ficción y que ahora se visualiza como una realidad.
La evolución de la inteligencia artificial se presenta como una realidad inevitable que avanzará de manera exponencial, similar al crecimiento tecnológico. Se sugiere que, en poco tiempo, la IA generará nuevos empleos y se convertirá en una presencia omnipresente, tan esencial como lo son actualmente las conexiones a internet o los dispositivos móviles. Este análisis reflexiona sobre el gran impacto de la IA en nuestra sociedad y destaca su potencial para transformar fundamentalmente la forma en que vivimos y trabajamos.

Uno de los desafíos más complejos en el ámbito de la inteligencia artificial es lograr que las máquinas comprendan el lenguaje natural. Hacer que las máquinas hablen es relativamente sencillo, pero lograr que realmente entiendan el significado de las palabras es extremadamente complicado, ya que ciertas palabras pueden tener múltiples significados y las máquinas operan siguiendo reglas predefinidas que, al intentar traducirlas en código, pueden generar redundancias significativas.

Aunque la dificultad no implica imposibilidad, y en el video se presenta un ejemplo el cual es una IA _(Watson)_ entrenada con una gran cantidad de datos capaz de comprender las complejidades del lenguaje natural al punto de competir con los mejores jugadores de Jeopardy. Este avance representa un hito en la capacidad de la inteligencia artificial para abordar la comprensión del lenguaje natural. Watson analiza preguntas, las descompone, busca en una amplia cantidad de documentos e información, compara datos y llega a una respuesta potencial, todo en cuestión de segundos gracias al trabajo realizado por los trabajadores de IBM y la implementación de diversos algoritmos y cálculos matemáticos. Este logro destaca el poder de la IA y la tecnología en la investigación, así como su potencial aplicación en la resolución de problemas complejos a nivel mundial.
Adicionalmente, unos investigadores en inteligencia artificial desarrollaron un sistema capaz de debatir en tiempo real. Al igual que Watson, este sistema se entrena con una gran cantidad de datos, documentos, gramática y experiencias de debates reales para aprender de sus oponentes. En cuestión de segundos, la IA busca, consulta, conecta e investiga sobre el tema en debate, proporciona una respuesta y, de manera impresionante, prepara argumentos para refutar o incluso añadir un toque de humor al debate, todo sin titubeos, nerviosismo, muletillas ni restricciones. Aunque eso sí, la IA debe al menos escuchar por 4-5 minutos al ponente contrario para poder generar una respuesta adecuada.
Aunque la habilidad de una máquina para debatir de manera perfecta puede resultar algo monótona de escuchar, este avance ofrece un potencial significativo en áreas como la tutoría, la enseñanza, la orientación o la investigación. La capacidad de la IA para procesar información y presentar hechos de manera objetiva podría ser invaluable en campos donde la ayuda computacional es esencial y podría abrir nuevas posibilidades para la resolución de problemas que, sin la intervención de la inteligencia artificial, serían prácticamente insuperables para los seres humanos.

Aquí se habla de la inteligencia artificial en la calle, como esos carros automáticos que ya existen en versiones básicas, tipo el carro de pizza de Ford que se mostro en el video donde hacía las entregas de manera autónoma. También enseñan un proyecto de Uber que quería que los carros se manejaran solitos para llevar a la gente. Es básicamente enseñarle a una máquina a que se dé sus paseos sola.
La primera cosa a tener en cuenta es el desmadre que hay en una ciudad y lo impredecible que puede ser manejar un carro. Para los humanos, hay ciertas condiciones que nos pueden limitar a manejar bien y seguro, como el clima o la oscuridad de la noche. Para un sistema automático, eso no es problema, pero hay otros rollos, como que haya un montón de niños jugando y la pelota se les vaya a la calle. Ahí, el sistema tiene que echarle coco con algo llamado **_"Deep Learning"_** para entender todo el contexto y evitar desastres.
También hay que pensar en qué pasa si la máquina que opera el carro falla o tiene algún defecto. Eso podría causar un accidente.

Aquí se menciona una frase bastante intrigante: _"Queremos que las máquinas piensen como los humanos"_. Pero la realidad es que, hasta ahora, las máquinas están lejos de eso. Actualmente, solo las programamos para cumplir con un objetivo específico y no tienen individualidad ni la capacidad de aprender en diferentes contextos. Aunque, de alguna manera, las máquinas sí pueden aprender solas. Hace un tiempo, hubo una máquina que se enseñó a sí misma a jugar damas chinas y resultó ser mejor que su propio creador. Además, otra persona desarrolló una inteligencia artificial para jugar Backgammon al punto de competir en torneos reales. Este sistema analiza millones de datos, evaluando las posiciones de las piezas para tomar las mejores decisiones y ganar el juego. Todo esto se basa en el **_"aprendizaje automático"_**, donde la máquina busca patrones, analiza datos y utiliza esos patrones para tomar decisiones efectivas.

Un ejemplo fascinante mostrado es el juego chino llamado GO, que tiene más posiciones posibles que átomos en el universo. Aquí, una inteligencia artificial aprendió a jugar por sí sola, sin necesidad de partidas de ejemplo, simplemente jugando consigo misma. Mientras que el aprendizaje automático suele implicar millones de datos, esta IA aprendió mediante ensayo y error, similar a cómo lo haría un humano. Sin embargo, un humano llevaría miles de años para alcanzar el nivel que esta IA logró en el juego, y en el proceso, generó sus propios datos de aprendizaje. Es realmente sorprendente ver cómo las máquinas pueden aprender por sí mismas en la actualidad.

A lo largo del tiempo, las industrias y los empleos han experimentado numerosas transformaciones, con la desaparición de algunos roles y la creación de nuevos. La llegada del internet y la era digital ha dejado obsoletos trabajos como el mecanógrafo, operador telefónico, agente de viajes, etc. Revolucionando también la manera en que se escucha y consume música. Sin embargo, este cambio no solo trajo aspectos negativos, sino que generó nuevos empleos como administradores de redes sociales, ventas por internet, desarrolladores de aplicaciones, entre otros.
En la actualidad, la automatización se ha vuelto esencial en fábricas y tiendas para optimizar procesos, utilizando robots para llevar a cabo tareas consideradas difíciles. Estos robots son una realidad en las empresas, y con la incorporación de la inteligencia artificial (IA) se espera una mayor optimización y eficiencia en los procesos, lo que plantea la posibilidad de prescindir del factor humano en ciertos aspectos.

Aunque esto podría llevar a la pérdida de empleos para los humanos, hay una perspectiva diferente. La presencia de robots requerirá supervisión humana para aspectos que estén fuera de su alcance, así como mantenimiento y capacitación inicial sobre cómo realizar tareas específicas. Por ejemplo, en el video se mostró que una empresa creó un brazo robótico capaz de realizar tareas precisas y tediosas, este se entrena por una persona para luego operar de manera autónoma y reconocer posibles errores. De esta manera, se ejemplifico que un empleado que realizaba este trabajo, ahora pasó a trabajar para el brazo, es decir su puesto cambió completamente, ahora solo supervisaba y monitoreaba las tareas del brazo.
Es innegable que los empleos están en constante evolución, especialmente cuando se trata de tecnología. Se ve un futuro donde los empleos actuales pueden volverse obsoletos, pero surgirán nuevos roles, posiblemente con menos exigencia física. La incertidumbre radica en evitar una crisis de desempleo y en dirigir de manera responsable el rumbo que nos llevará la robótica y la inteligencia artificial en el futuro.

En el video, se destaca cómo la inteligencia artificial puede ser de gran ayuda para niños desde muy temprana edad, facilitando el aprendizaje en diversas áreas como lectura, matemáticas, historia e investigación. Un ejemplo práctico que se mostró es una aplicación que utiliza IA para ampliar el vocabulario de los niños. La aplicación adapta el aprendizaje a cada niño, reconociendo que no todos aprenden al mismo ritmo ni de la misma manera. La IA recopila datos de las palabras que el niño aprende, evalúa su nivel de vocabulario y decide si puede avanzar a un vocabulario más avanzado o si es necesario continuar con palabras del mismo nivel. Esta individualización del aprendizaje desde una edad temprana tiene un impacto positivo en la vida adulta, incluso nos muestran resultados y vemos que el niño puede comprender y aplicar el significado de las palabras en situaciones de la vida real de manera efectiva.

Otro proyecto presentado es una inteligencia artificial que actúa como tutor, una IA diseñada para ayudar a estudiantes universitarios. Esta tiene acceso a una gran cantidad de datos que puede utilizar para facilitar el estudio. Hace preguntas y, si las respuestas son correctas, sigue avanzando en la enseñanza, en caso contrario, adapta su enfoque y plantea preguntas más específicas para guiar al estudiante hacia la comprensión del tema objetivo. Además, si el estudiante no sabe la respuesta, puede solicitar pistas o que la IA sea un poco más específica. La clave es que esta IA personaliza la experiencia de aprendizaje para cada estudiante, reconociendo las diferentes formas en que las personas aprenden. Este enfoque individualizado promete mejorar la calidad de la educación, asegurando que cada estudiante reciba la ayuda que necesita de manera efectiva en el tiempo que él prefiera.

Nos fascina la idea de fusionarnos con las maquinas como en las películas de ficción por ejemplo Iron Man, donde es increíble como con ayuda de la tecnología los humanos pueden mejorar sus habilidades y su biología. Actualmente en la realidad lo hemos aprovechado muy poco y es muy temprana las tecnologías que se han desarrollado para poder mejorar a los humanos.

¿Se pueden mejorar el humano con las maquinas? La respuesta a esta pregunta es que en efecto si se pueden mejorar a los humanos con las maquinas y esto combinado con IA sería una combinación perfecta para crear lo que solamente se puede ver en la televisión y en las películas

Muchas personas e investigadores se han preguntado si la IA puede influir en nuestro cuerpo, de tal manera que seamos mitad artificial mitad humano, es decir, ¿Podría la IA ayudar a personas sin visión a ver o personas con problemas auditivos a escuchar?. Pues bien, se presentó un caso donde muestran a una persona con problemas visuales, esta persona quería adaptarse a su ceguera mediante el ejercicio en especial correr, quería estar en un maratón evidentemente es algo muy difícil por su discapacidad visual. Con ayuda de una empresa y la IA crearon unas pulseras para poder ayudarlo. Mediante el sentido háptico, que no es más que la capacidad que tenemos al sentir algo (como cuando nuestro celular vibra y lo sentimos) se guía al usuario, si se sales del camino vibra de un lado o de otro, así podrás mantenerte en el camino. Esta tecnología crea un corredor virtual al trazar una ruta GPS y aprendizaje automático y con la retroalimentación aptica aseguras que estas dentro del corredor virtual. Si no recibes vibraciones hápticas quiere decir que estas en un buen camino.

En el contexto del almacenamiento de datos y la necesidad de salvaguardar nuestra información en línea, surge el concepto de privacidad de datos. Al introducir tus datos personales, como nombre y dirección, en internet, esta información se almacena en la vasta nube de internet, sin tener certeza sobre quién tiene acceso a estos datos. Algunos temen que, con el avance de la inteligencia artificial y tecnologías como el reconocimiento facial o biometría, la privacidad esté destinada a desaparecer. Sin embargo, muchos no se dan cuenta de que la privacidad tal como la conocíamos ya no existe, ya que nuestros datos están digitalizados en internet, potencialmente utilizados para entrenar inteligencias artificiales o, peor aún, comercializados a terceros.
En la actualidad, nos encontramos rodeados de dispositivos con cámaras y micrófonos, generando dudas sobre si estos podrían estar activos, escuchándonos o observándonos, y almacenando nuestros datos para su análisis en diversas plataformas. El fenómeno de hablar sobre algo y luego recibir anuncios relacionados refuerza la creciente percepción de que las máquinas nos observan y escuchan. En este entorno, la privacidad de nuestros datos en la era digital prácticamente ha dejado de existir.

Anteriormente se mencionaron las ventajas del reconocimiento facial, que van desde servir como firma digital hasta ser una alternativa más rápida que la huella dactilar. Además, su utilidad se extiende a la detección de posibles delincuentes o la verificación de la identidad de una persona en comparación con sus documentos físicos. Al proyectarnos hacia el futuro, cabe la posibilidad de prever delitos que alguien pueda cometer, subrayando aún más la capacidad potencial de estas tecnologías para cambiar la forma en que abordamos la seguridad y la identificación personal. Aunque, detectar o juzgar a alguien por el simple hecho de verlo es estereotipar a las personas, aunque con verlo a simple vista podemos decidir si alguien es divertido, enojon, o da mala espina, esto no es lo más eficaz para determinar si alguien es un delincuente o no.

Volviendo al ámbito de la investigación, se destaca la relevancia de Watson y la inteligencia artificial, especialmente en el sector de la salud. Watson, con su capacidad para analizar conexiones entre millones de artículos y libros, se destaca como una herramienta invaluable. Su capacidad para descubrir tratamientos novedosos mediante el uso de medicamentos ya existentes o proporcionar un nuevo enfoque a fármacos conocidos es especialmente destacada. Este proceso, que sería enormemente difícil para los seres humanos debido a la abrumadora cantidad de información, se convierte en una tarea posible en cuestión de segundos gracias a la ayuda de la IA y Watson.
La inteligencia artificial se convierte en un aliado poderoso para los investigadores en la búsqueda de curas para enfermedades que aún no tienen solución, como el cáncer, el parkinson, el sida, entre otras. Aunque la información necesaria puede estar presente en la inmensa biblioteca de libros de medicina, la tarea de analizar cada uno de ellos se vuelve humanamente imposible. Aquí es donde entra en juego una inteligencia artificial bien entrenada, como la representada por Watson. Su capacidad para procesar grandes cantidades de datos de manera eficiente no solo acelera la investigación, sino que también reduce significativamente el tiempo necesario para descubrir tratamientos y posiblemente curas para enfermedades que actualmente consideramos incurables.
Este enfoque promete transformar radicalmente la investigación médica, ofreciendo nuevas perspectivas y acelerando los avances que podrían tener un impacto directo en la calidad de vida de las personas. Al aprovechar la inteligencia artificial de manera estratégica, los investigadores pueden abordar desafíos médicos complejos con una velocidad y eficiencia que anteriormente parecían inalcanzables. En última instancia, la colaboración entre la mente humana y la potencia analítica de la inteligencia artificial presenta un horizonte prometedor para el futuro de la medicina y la investigación científica, ya que, existen cosas que la inteligencia artificial puede hacer y los humanos no y existen cosas que un humano puede hacer y la IA no.

En la actualidad, la inteligencia artificial presenta limitaciones notables, restringida a realizar tareas específicas en contextos predeterminados. Sin embargo, no podemos dejar de pensar que en un futuro, la IA podría lograr realizar prácticamente cualquier tarea en el contexto que se presente. Esta capacidad de llevar a cabo diversas acciones en diferentes situaciones se conoce como inteligencia general artificial, la misma que los seres humanos poseemos en la actualidad.

Actualmente, las máquinas de inteligencia artificial solo pueden ejecutar las tareas para las cuales fueron programadas. Si asignamos a un robot la tarea de limpiar la casa y luego intentamos que juegue fútbol, fallará en todos los intentos, ya que nunca fue programado para interactuar con una pelota o anotar un gol. Surge un temor comprensible al contemplar la posibilidad de que la inteligencia artificial alcance un nivel que le permita replicar a un ser humano.

La idea de alcanzar la singularidad de la IA, donde esta superaría la inteligencia humana, plantea interrogantes y reflexiones. Sin embargo, en lugar de temerle a una entidad más inteligente, podríamos ver esta singularidad como una oportunidad para aprender y mejorar en diversos aspectos. La sociedad, sin embargo, tiende a resistirse a aceptar la posibilidad de que algo sea más inteligente que un humano, percibiéndolo como una amenaza potencial.
Es importante reconocer que, en un principio, nuestros padres eran más inteligentes y nos guiaron, proporcionándonos el conocimiento y la orientación necesarios para enfrentar el mundo. Ahora, nos toca a nosotros guiar y dar forma a la inteligencia artificial, asegurándonos de que comprenda los objetivos de los humanos y entienda nuestra cultura y mente. Esta alineación es esencial para evitar que la IA tome caminos inesperados y garantizar que se integre de manera armoniosa con nosotros, evitando posibles amenazas a nuestra existencia. Entonces, después de todo tener a un ente más inteligente que nosotros no suena tan mal viéndolo desde esta perspectiva y con estas regulaciones.
Es crucial reconocer que la IA es una elección que los seres humanos están haciendo conscientemente. La forma en que llevemos y moldeemos esta herramienta en el futuro dependerá de nuestras decisiones actuales. Debemos dirigir el desarrollo de la inteligencia artificial de manera ética y cuidadosa, considerando su impacto en la sociedad y garantizando que sirva para el beneficio y avance de la humanidad.

---

# Ensayo sobre "La Teoría de las Inteligencias Múltiples"

La teoría de Howard Gardner propone que la vida humana requiere del desarrollo de diversos tipos de inteligencia, cada uno de estos tipos engloba su propia serie de habilidades, que sobrepasan el pensamiento de _"ser listo"_ o _"ser ágil mentalmente"_, y sin embargo, estas inteligencias artificiales nos aportan mucha ayuda a la hora de enfrentar desafíos que pueden o no estar en constante cambio.

Hay un hombre llamado Howard Gardner que es profesor en Harvard, es psicólogo e investigador. Él dijo que la inteligencia no es solo una cosa, sino que hay 8 tipos de inteligencia que funcionan más o menos solos, pero también juntos. A eso lo llama la teoría de las inteligencias múltiples
Primero que nada, recordemos cual es la definición de inteligencia. Esta se define como la capacidad o facultad de entender, razonar, saber, aprender y de resolver problemas mediante lo aprendido. Es decir, la inteligencia no es saber mucho sino es saber que hacer con lo que ya se sabe.
Con esta teoría, Gardner no entra en contradicción con la definición científica de la inteligencia, como la _"capacidad de solucionar problemas o elaborar bienes valiosos"_, pero a la vez la replantea de una manera radical y también polémica. Esto es lo que hace de la Teoría de las Inteligencias Múltiples algo tan interesante.

Saber hablar y comunicarnos con los demás es algo que todos compartimos, independientemente de la cultura. Desde que somos chicos, aprendemos a usar nuestro idioma local para poder expresarnos de manera efectiva.

**La inteligencia lingüística** no se trata solo de hablar bien, sino también de otras formas de comunicación, como escribir o expresarse gestualmente para el caso de los sordos.
Las personas que son realmente buenas en esto de comunicarse demuestran tener una inteligencia lingüística superior.
Algunas características de esta inteligencia son las siguientes:

- **Capacidades implicadas:** Tener la habilidad de entender el orden y significado de las palabras en la lectura, escritura, al hablar y escuchar.
- **Habilidades relacionadas:** Hablar y escribir de manera efectiva, así como tener una buena memoria y dicción.
- **Beneficios al desarrollar esta inteligencia:** Mejora la imaginación y creatividad, agiliza la mente, promueve un buen entendimiento, aumenta la ortografía, facilita el pensamiento, brinda relajación, expone a nuevas experiencias e intereses.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Participar en debates, mantener un diario, realizar lecturas en voz alta, hacer presentaciones, utilizar libros, computadoras, grabadoras, entre otros.

Durante décadas,**la inteligencia lógico-matemática** fue considerada la inteligencia en bruto. Suponía el axis principal del concepto de inteligencia, y se empleaba como filtro para detectar cuán inteligente era una persona, muchos sistemas como lo es el educativo le toman mas importancia a esta inteligencia que a todas las demás.
Esta inteligencia esta relacionada con la capacidad de solventar problemas relacionados con lo matemático y lo lógico siguiendo algunas reglas de lógica.
Las características de esta inteligencia son las siguientes:

- **Capacidades implicadas:** La habilidad para reconocer patrones abstractos en un contexto matemático, realizar cálculos numéricos, plantear y confirmar suposiciones, emplear el método científico y aplicar razonamientos inductivos y deductivos.
- **Habilidades relacionadas:** Pensar de manera lógica, encontrar soluciones a problemas y ensamblar piezas de un rompecabezas.
- **Beneficios al desarrollar esta inteligencia:** Mejorala capacidad de realizar cálculos, fomenta un sólido desarrollo de procesos y promueve una comprensión profunda de fórmulas para tomar decisiones.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Resolución de desafíos abstractos, ejecución de cálculos mentales, utilización de calculadoras, participación en entrevistas cuantitativas, juegos, puzzles, entre otras habilidades relacionadas .

**La inteligencia visual y espacial** es la que obtenemos a través de la vista, esta habilidad se refiere a la capacidad de percibir y comprender el entorno, así como los objetos que lo componen, desde distintos ángulos y perspectivas. Implica la destreza de visualizar y manipular mentalmente elementos visuales, facilitando la interpretación de información espacial. El nivel de esta inteligencia puede medir la capacidad o el éxito que tendremos al efectuar algunas tareas como el manejar un auto, orientarse en un mapa o ciudad o incluso darle instrucciones a alguien más.
Esta inteligencia tiene algunos aspectos biológicos, el hemisferio derecho, especialmente en personas diestras, desempeña un papel crucial en el cálculo espacial. Lesiones en la región posterior derecha pueden afectar la orientación espacial, el reconocimiento facial, la apreciación de detalles pequeños y otras habilidades. Pacientes con daño en estas áreas a menudo intentan compensar con estrategias lingüísticas, aunque estas no resultan eficaces. En contraste, las personas ciegas demuestran que la inteligencia espacial es independiente de una modalidad sensorial específica, ya que pueden desarrollar capacidades espaciales a través de otros sentidos, como el tacto.
Algunas de las características de la inteligencia visual y espacial son las siguientes:

- **Capacidades implicadas:** Tener la habilidad para expresar ideas de manera visual, generar imágenes mentales, observar detalles visuales y realizar dibujos
- **Habilidades relacionadas:** Crear imagenes con destreza y tener la capacidad de visualizar con precisión.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Recursos y métodos pedagógicos que se pueden utilizar para cultivar esta forma de inteligencia incluyen actividades artísticas, mapas mentales, visualizaciones, metáforas, vídeos, gráficos, mapas, juegos de construcción, entre otros.

La música es un arte universal presente en todas las culturas, manifestándose en formas más o menos complejas. Desde la perspectiva de _Howard Gardner_ y sus colaboradores, esta omnipresencia musical sugiere la existencia de una **inteligencia musical-auditiva** inherente en todas las personas. Ciertas áreas del cerebro desempeñan funciones relacionadas con la interpretación y composición musical. Similar a otras formas de inteligencia, la inteligencia musical no es estática; puede ser entrenada y perfeccionada a lo largo del tiempo.
Esta forma de inteligencia abarca conceptos como la sensibilidad al ritmo, al tono y al timbre. Aquellas personas que tienen un contacto frecuente con la música suelen experimentar una sensibilidad notable hacia estos elementos. Quienes estan altamente involucrados en el mundo musical a menudo encuentran que esta sensibilidad se vuelve tan evidente que incluso se preguntan cómo no la notaban anteriormente.
Principales características de esta inteligencia son:

- **Capacidades implicadas:** Capacidad para escuchar, cantar, tocar instrumentos, así como analizar de manera general el sonido.
- **Habilidades relacionadas:** Componer y analizar música o sonidos.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Practicar el canto, tocar instrumentos musicales, escuchar música de manera activa, asistir a conciertos, utilizar cintas de música, entre otros.

Se sugiere que se introduzcan experiencias musicales desde el periodo de gestación mediante la exposición a diversos géneros durante el embarazo. Además, se pueden incorporar juegos musicales adecuados a su edad y elementos musicales en su entorno diario, como juguetes y música durante actividades cotidianas. Proporcionar experiencias directas, como participar en clases de música o disfrutar de eventos musicales, también contribuye a fortalecer esta inteligencia desde temprana edad. Estas prácticas fomentan un desarrollo integral de la conexión del niño con la música.

**La inteligencia corporal-kinestésica** abarca las destrezas motrices y corporales, incorporando aspectos como la fuerza, coordinación, equilibrio, velocidad, flexibilidad y la habilidad para manejar herramientas. Esta inteligencia influye en por qué algunas personas destacan en deportes, mientras que otras pueden sobresalir en actividades que requieren precisión, como el recorte preciso de objetos.
Los aspectos biológicos de esta inteligencia vienen desde el control del movimiento corporal que se encuentra en la corteza motora, donde cada hemisferio dirige los movimientos del lado opuesto del cuerpo. En personas diestras, este control generalmente reside en el hemisferio izquierdo. La capacidad para realizar movimientos voluntarios puede dañarse, incluso en aquellos que pueden ejecutar los mismos movimientos de manera refleja o involuntaria.
Algunas características de esta inteligencia son las siguientes:

- **Capacidades implicadas:** Realizar actividades que demandan fuerza, velocidad, flexibilidad, coordinación óculo-manual y equilibrio.
- **Habilidades relacionadas:** Emplear las manos para crear o realizar reparaciones, así como expresarse a través del cuerpo.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Actividades manuales, teatro, danza, prácticas de relajación, uso de materiales táctiles, participación en deportes, entre otros.

_Howard Gardner_ introdujo una nueva idea llamada **"inteligencia naturalista"**. Esto significa que todos tenemos una habilidad especial para entender y disfrutar de la naturaleza que nos rodea, como los animales, las plantas y el clima. Todos usamos esta inteligencia cuando reconocemos cosas en nuestro entorno, como el cambio de clima.

**La inteligencia intrapersonal** se refiere a nuestro entendimiento interno, cómo vemos y entendemos nuestras emociones y distinguimos entre ellas. Implica la capacidad de poner nombre a nuestros sentimientos y usarlos para interpretar y guiar nuestro comportamiento. Aquellos con una inteligencia intrapersonal fuerte tienen modelos sólidos de sí mismos, pero esta forma de inteligencia, al ser la más privada, necesita otras formas de expresión para ser observada.
La inteligencia intrapersonal nos ayuda a comprendernos mejor y a trabajar con nosotros mismos. El sentido de uno mismo es una creación sobre quiénes somos, una invención que cada individuo construye para sí mismo. En este viaje de autoconocimiento, exploramos nuestras emociones y desarrollamos un entendimiento profundo de nuestra propia identidad.
Algunas características son estas:

- **Capacidades implicadas:** Capacidad para establecer metas, evaluar fortalezas y debilidades personales, y controlar el propio pensamiento.
- **Habilidades relacionadas:** Practicar la meditación, demostrar disciplina personal, mantener la compostura y ofrecer el mejor esfuerzo.
- **Beneficios al desarrollar esta inteligencia:** Mejor cocnocimiento de uno mismo, habilidad para gestionar emociones, mayor productividad y equilibrio emocional.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Actividades centradas en la autoestima, redacción de diarios, proyectos individuales, y prácticas de meditación, entre otras.

Por otro lado, **la inteligencia interpersonal** se forja en la habilidad para percibir diferencias entre las personas, especialmente en cuanto a sus estados de ánimo, temperamentos, motivaciones e intenciones. Un individuo hábil en esta inteligencia puede comprender las intenciones y deseos de los demás, incluso si estos intentan ocultarlos. Este don se manifiesta de manera excepcional en líderes religiosos, políticos, terapeutas y educadores, destacando que no está limitado por el lenguaje.
Las investigaciones sobre los aspectos biológicos de esta inteligencia apuntan consistentemente a que los lóbulos frontales desempeñan un papel fundamental en la inteligencia interpersonal. Daños en esta área pueden provocar cambios significativos en la personalidad, alterando fundamentalmente la naturaleza de la persona afectada, incluso si otras habilidades de resolución de problemas permanecen intactas tras la lesión. La evidencia biológica de esta forma de inteligencia se extiende más allá, abordando factores que a menudo se consideran exclusivos de la especie humana.
Principales características de esta inteligencia son las siguientes:

- **Capacidades implicadas:** Colaborar con individuos y asistirles en la identificación y superación de desafíos.
- **Habilidades relacionadas:** Habilidad para identificar y reaccionar ante los sentimientos y personalidades de los demás.
- **Beneficios al desarrollar esta inteligencia:** Fortalecimiento del autoconocimiento y toma de decisiones, mejora del desempeño laboral, reducción del estrés, y fomento del desarrollo personal.
- **Actividades y materiales de enseñanza que se podrían emplear para desarrollar esta inteligencia:** Prácticas de aprendizaje cooperativo, sesiones de tutoría, juegos de mesa y materiales para actividades teatrales, entre otros.

---

# Problema de los 8 alfiles

Coloca ocho alfiles (cuatro negros y cuatro blancos) en un tablero deajedrez reducido, tal como se ve en la figura. El problema consiste en hacer que los alfiles negros intercambien sus posiciones con los blancos, ningún alfil debe atacar en ningún momento otro del color opuesto. Se deben alternar los movimientos, primero uno blanco, luego uno negro, luego uno blanco y así sucesivamente.
Para explicar la solución de este problema vamos a numerar cada casilla como se muestra a continuación:

| 1   | 2   | 3   | 4   |
| :-- | :-- | :-- | :-- |
| 5   | 6   | 7   | 8   |
| 9   | 10  | 11  | 12  |
| 13  | 14  | 15  | 16  |
| 17  | 18  | 19  | 20  |

La notación por la cual se opto es la siguiente:

- **AN:** Alfiles Negros
- **AB:** Alfiles Blancos

La posición inicial de los alfiles negros es en las casillas 1,2,3,4 y para los alfiles blancos, se encuentran en las casillas 17,18,19,20, teniendo dos alfiles que se moverán en las casillas blancas y dos que se moverán en las negras por cada color de las piezas, el tablero inicial se ve de esta manera:

| **AN** | **AN** | **AN** | **AN** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| 9      | 10     | 11     | 12     |
| 13     | 14     | 15     | 16     |
| **AB** | **AB** | **AB** | **AB** |

La partida inicia con el movimiento de las piezas blancas, y el primer movimiento lo realiza el alfil desde la casilla 18 hasta la casilla 15. Luego, las piezas negras responden con su primer movimiento, moviendo el alfil desde la casilla 3 hasta la casilla 6. Teniendo en cuenta estos movimientos, el tablero se verá así:

| **AN** | **AN** | 3      | **AN** |
| :----- | :----- | :----- | :----- |
| 5      | **AN** | 7      | 8      |
| 9      | 10     | 11     | 12     |
| 13     | 14     | **AB** | 16     |
| **AB** | 18     | **AB** | **AB** |

En el segundo turno, el alfil blanco posicionado en la casilla 17 se desplaza hacia la casilla 8, concluyendo así el turno. Simultáneamente, el alfil negro posicionado en la casilla 4 se traslada a la casilla 13, dando como resultado la siguiente disposición en el tablero:

| **AN** | **AN** | 3      | 4      |
| :----- | :----- | :----- | :----- |
| 5      | **AN** | 7      | **AB** |
| 9      | 10     | 11     | 12     |
| **AN** | 14     | **AB** | 16     |
| 17     | 18     | **AB** | **AB** |

Ahora, el alfil blanco que ocupa la casilla 19 se traslada a la casilla 14. De manera correspondiente, el alfil negro en la casilla 2 se desplaza hacia la casilla 7. Este patrón de movimientos resulta en la siguiente configuración del tablero:

| **AN** | 2      | 3      | 4      |
| :----- | :----- | :----- | :----- |
| 5      | **AN** | **AN** | **AB** |
| 9      | 10     | 11     | 12     |
| **AN** | **AB** | **AB** | 16     |
| 17     | 18     | 19     | **AB** |

El alfil ubicado en la posición 15 se desplazará hacia la casilla 5, concluyendo así el turno de las piezas blancas. Simultáneamente, el alfil negro en la casilla 6 se moverá hacia la casilla 16. La disposición resultante del tablero quedará de la siguiente manera:

| **AN** | 2      | 3      | 4      |
| :----- | :----- | :----- | :----- |
| **AB** | 6      | **AN** | **AB** |
| 9      | 10     | 11     | 12     |
| **AN** | **AB** | 15     | **AN** |
| 17     | 18     | 19     | **AB** |

En este punto, ambos jugadores tienen la oportunidad de meter un alfil al lado contrario. Por parte de las piezas blancas, el alfil en la casilla 8 se desplazará hacia la casilla 3. Del otro lado, el alfil negro en la casilla 13 será movido y colocado en la casilla 18, viéndose así:

| **AN** | 2      | **AB** | 4      |
| :----- | :----- | :----- | :----- |
| **AB** | 6      | **AN** | 8      |
| 9      | 10     | 11     | 12     |
| 13     | **AB** | 15     | **AN** |
| 17     | **AN** | 19     | **AB** |

Ahora el alfil de las piezas blancas situado en la casilla 14 se desplazará a la casilla 9. Luego, el alfil de las piezas negras de la casilla 7 se moverá a la casilla 12. Y hechos estos movimientos, el tablero queda de la siguiente manera:

| **AN** | 2      | **AB** | 4      |
| :----- | :----- | :----- | :----- |
| **AB** | 6      | 7      | 8      |
| **AB** | 10     | 11     | **AN** |
| 13     | 14     | 15     | **AN** |
| 17     | **AN** | 19     | **AB** |

Para este turno, el jugador de las piezas blancas, moverá el alfil de la casilla 5 a la casilla 10. Mientras tanto, el jugador de las piezas negras desplazará el alfil de la casilla 16 a la casilla 11. La configuración actualizada del tablero será la siguiente:

| **AN** | 2      | **AB** | 4      |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| **AB** | **AB** | **AN** | **AN** |
| 13     | 14     | 15     | 16     |
| 17     | **AN** | 19     | **AB** |

Ahora, retornaremos el alfil de la casilla 9 a la casilla 19. Asimismo, devolveremos el alfil de la casilla 12 a la casilla número 2. El tablero será el siguiente:

| **AN** | **AN** | **AB** | 4      |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| 9      | **AB** | **AN** | 12     |
| 13     | 14     | 15     | 16     |
| 17     | **AN** | **AB** | **AB** |

Durante este turno, ambos jugadores tienen la opción de llegar al lado contrario su segundo alfil. El jugador de las piezas blancas moverá su alfil de la casilla 10 a la casilla 4. Mientras que, el jugador de las piezas negras moverá su alfil de la casilla 11 para retirarlo y colocarlo en la casilla 17.

| **AN** | **AN** | **AB** | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| 9      | 10     | 11     | 12     |
| 13     | 14     | 15     | 16     |
| **AN** | **AN** | **AB** | **AB** |

Si podemos notarlo, los movimientos de cada turno han sido prácticamente los mismos, siguiendo un patrón de _espejo_, con ambos jugadores guardando el mismo número de alfiles. Ahora, el jugador de las piezas blancas desplazará su alfil de la casilla 20 a la casilla 10. Simultáneamente, el jugador de las piezas negras moverá el alfil de la casilla 1 a la casilla 11.

| 1      | **AN** | **AB** | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| 9      | **AB** | **AN** | 12     |
| 13     | 14     | 15     | 16     |
| **AN** | **AN** | **AB** | 20     |

Ahora procedemos a mover los alfiles de las esquinas para facilitar más movimientos sin el riesgo de capturas mutuas. El alfil blanco de la casilla 3 se trasladará a la casilla 9, mientras que el alfil negro de la casilla 18 se moverá a la casilla 12. La configuración actualizada del tablero será la siguiente:

| 1      | **AN** | 3      | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| **AB** | **AB** | **AN** | **AN** |
| 13     | 14     | 15     | 16     |
| **AN** | 18     | **AB** | 20     |

El jugador con las piezas blancas moverá su alfil desde la casilla 10 a la casilla 13. En una correspondencia en espejo, el jugador con las piezas negras moverá su alfil desde la casilla 11 a la casilla 8.

| 1      | **AN** | 3      | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | **AN** |
| **AB** | 10     | 11     | **AN** |
| **AB** | 14     | 15     | 16     |
| **AN** | 18     | **AB** | 20     |

Quitaremos los alfiles de las casillas 19 y 2, del color respectivo. El alfil blanco de la casilla 19 se desplazará a la casilla 16, mientras que el alfil negro de la casilla 2 se moverá a la casilla 5.

| 1      | 2   | 3   | **AB** |
| :----- | :-- | :-- | :----- |
| **AN** | 6   | 7   | **AN** |
| **AB** | 10  | 11  | **AN** |
| **AB** | 14  | 15  | **AB** |
| **AN** | 18  | 19  | 20     |

Procederemos a cruzar los alfiles hacia su lado opuesto. Guardaremos el alfil blanco de la posición 16 en la posición 1. De la misma forma, el alfil negro de la posición 5 será retirado y colocado en la posición 20. La disposición resultante del tablero será la siguiente:

| **AB** | 2   | 3   | **AB** |
| :----- | :-- | :-- | :----- |
| 5      | 6   | 7   | **AN** |
| **AB** | 10  | 11  | **AN** |
| **AB** | 14  | 15  | 16     |
| **AN** | 18  | 19  | **AN** |

Hasta aquí, dos alfiles han sido ubicados en su posición opuesta y los otros dos permanecen fuera.
Ahora, el alfil blanco de la casilla 9 se desplazará hacia la casilla 6, mientras que el alfil negro de la casilla 12 se moverá a la casilla 15. Estos movimientos llevarán al tablero al siguiente estado:

| **AB** | 2      | 3      | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | **AB** | 7      | **AN** |
| 9      | 10     | 11     | 12     |
| **AB** | 14     | **AN** | 16     |
| **AN** | 18     | 19     | **AN** |

Ahora, moveremos el alfil blanco de la casilla 13 a la casilla 7 y el alfil negro de la casilla 8 a la casilla 14, alineándolos para que en los turnos siguientes puedan ser llevados al lado contrario. El tablero quedará de la siguiente manera:

| **AB** | 2      | 3      | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | **AB** | **AB** | 8      |
| 9      | 10     | 11     | 12     |
| 13     | **AN** | **AN** | 16     |
| **AN** | 18     | 19     | **AN** |

Podemos notar que ya estamos cerca de lograr cambiar la posición de todos los alfiles. En el próximo movimiento, llevaremos al lado contrario un alfil de cada color.
Comenzaremos moviendo el alfil blanco de la casilla 6 a la casilla 3, y al mismo tiempo, el alfil negro de la casilla 15 será movido a la casilla 18 donde estará del lado objetivo. El tablero quedará de la siguiente manera:

| **AB** | 2      | **AB** | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | **AB** | 8      |
| 9      | 10     | 11     | 12     |
| 13     | **AN** | 15     | 16     |
| **AN** | **AN** | 19     | **AN** |

Finalmente, colocamos el último alfil blanco de la casilla 7 en la casilla 2, y al mismo tiempo, el último alfil negro de la casilla 14 en la casilla 19. Con esto, se cumple el objetivo del problema, logrando intercambiar los alfiles sin que ninguno se ataque, todo esto se llevo en un total de **_36 movimientos o bien, 18 turnos_**

| **AB** | **AB** | **AB** | **AB** |
| :----- | :----- | :----- | :----- |
| 5      | 6      | 7      | 8      |
| 9      | 10     | 11     | 12     |
| 13     | 14     | 15     | 16     |
| **AN** | **AN** | **AN** | **AN** |

---

# Problema de la búsqueda de islas

Este problema se trata de contar el número de elementos **_(islas)_** contenidos en una imagen, supongamos tener una matriz de 'n' x 'k', en dicha matriz, se tienen un cierto numero de islas, que podran estar integradas por elementos en horizontal, vertical o en el mejor de los casos, por un solo elemento, el punto es que debemos contar cada elemento si es que esta junto para poder determinar que es una sola isla.

A continuación se presentan los problemas o desafíos que presenta este problema:

1.  El primer desafío que se nos presenta es cómo identificar una isla del resto del tablero. Esto se soluciona simplemente poniendo una etiqueta diferente al del tablero. Por ejemplo, en una matriz podríamos meter un numero o letra cualquiera para determinar un espacio vacío o en este caso simulando el agua y a una isla otro número o letra diferente para poder diferenciar entre una y otra.

2.  Otro desafío que se puede presentar es como saber si la isla es vertical u horizontal o incluso una cruz, sea cual sea su "figura". Para detectar el espacio más cercano y al frente es decir el siguiente en la fila simplemente le sumariamos un 1 a la matriz en el eje horizontal y lo compararíamos con la etiqueta que corresponda, pero esto no es funcional si la isla se encuentra de manera vertical

3.  El ultimo desafío que tenemos es identificar el cómo saber que una isla ya fue visitada para no volver a tomarla en cuenta y caer en un bucle infinito. Este en particular es sencillo, ya que, podemos cambiar el numero o letra por otro diferente que no se encuentre en la matriz.

Durante este problema se utilizará la siguiente notación:

- Al **agua** le daremos el valor de **_a_**
- A las **islas** le daremos el valor de **_I_**
- A las **islas visitadas** le daremos el valor de **_v_**

**_Nota:_** Cuando se habla del _mapa_ se hace referencia a la matriz.

El problema fue resuelto en el lenguaje Python, a continuación veremos el código generado:

```python
import random
rows = 8
columns = 3
map = [[''] * columns for _ in range(rows)]
```

El tamaño del mapa es libre, puede asignarse cualquier numero de filas y columnas. En este ejemplo se tomaran las dimensiones 8 \* 3.
Todo el mapa se llena con la letra 'a',

Una vez generado el mapa, vamos a generar las islas, llamaremos a la funcion _createIslands_ donde llena aleatoriamente el mapa con las letras 'a' e 'I' de manera aleatoria para seguido de ello imprimir el mapa y saber cómo quedaron las islas.

```python
def createIslands():
	for x in range(rows):
		for y in range(columns):
			map[x][y] = random.choice('aI')
			print(f"{map[x][y]}", end="")
		print()
```

Una vez que tenemos las islas creadas, llamamos a la función de contar islas, esta es la que se encarga como bien lo dice su nombre, de contar los elementos y determinar cuando es una isla, para así saber cuantas islas existen dentro del mapa.

Primero se crea la variable _islas_ con un valor de 0 ya que, inicialmente no se tiene ninguna isla contada. Con esta variable iremos contando las islas en cada iteración. Seguido de esto se crean 2 ciclos for, uno dentro del otro para iterar cada uno de los espacios (de la matriz), en el for que se encuentra anidado tenemos la condición que nos dice: _si en lo que recorre la matriz se topa con una isla es decir la letra 'I'_, entonces llamamos a la función _findNeighbors_ que como bien dice su nombre, procederemos a ver si la isla consta de un elemento o de más.
El contador aumenta cuando finalice y se regresa de la función la variable que estuvo contando las islas en cada iteración.

```python
def countIslands():
	islands = 0
	for x in range(rows):
		for y in range(columns):
			if map[x][y] == 'I':
			findNeighbors(x,y)
			islands += 1
	return  islands
```

La función ya mencionada _(findNeighbors)_ se encarga de buscar todas las casillas por las cuales esta conformada la isla, esto se hace de manera recursiva, en este caso para la recursividad tenemos una condición que es para saber si ya no hay mas elementos dentro de la isla, si se sale del mapa, o si ya se contó el elemento. En cualquiera de esos casos la función acaba ahí y se regresa. Ya sea a la misma función o a contar la siguiente isla. Eso es la primera condición que se puede observar en el código.

La función recibe 2 parámetros que es la posición en la que se encuentra el iterador en donde en la primera vuelta es (0,0). Primero se verifica la condición que es: _si 'x' o 'y' son menores a 0 o mayores que la fila y la columna, quiere decir que nos salimos del mapa, y si la casilla es diferente de 'I' quiere decir que o ya fue visitada o es agua_.
Si ninguno de los casos anteriores se cumple, quiere decir que la isla aún tiene elementos por contemplar.

Entonces con los parámetros que se le pasan a la función, los cuales marcan la posición de la casilla, se marca como visitada es decir con el valor de 'v'. Y se continúa buscando en la isla si tiene mas elementos. Por ejemplo, en la primera vuelta se posiciona en la primera casilla es decir (0,0) y en esa casilla hay una letra 'I', entonces se cambia ese valor por 'v', después de eso se le resta uno a la fila, es decir, los parámetros que se usan para llamar a la misma función de manera recursiva serían (-1,0) como este valor entra en la condición se regresa a la función donde los valores son (0,0) y sigue el curso de la función.
Ahora se manda llamar asimismo la función pero con los valores (1,0) e igualmente lo hace con las columnas. Solo le suma o le resta al segundo parámetro de la función para buscar.

```python
def findNeighbors(x,y):
	if x < 0 or y < 0 or x >= rows or y >= columns or map[x][y] != 'I':
		return
	else:
		map[x][y] = 'v'
		findNeighbors(x - 1,y)
		findNeighbors(x + 1,y)
		findNeighbors(x,y - 1)
		findNeighbors(x,y + 1)
```

De esta manera, logramos que no importe la forma de la isla o el tamaño del mapa, siempre podrá contar las islas en el mapa.
Una vez terminado de recorrer toda la isla y cambiar los valores de 'I' a 'v', se regresa a la función _countIslands_ a sumar una isla al contador y seguir recorriendo la matriz hasta encontrar otra isla y repetir de nuevo todo el proceso recursivo.

Por último, revisaremos donde comienza todo, llamamos al método de crear islas para poder imprimir el mapa y posteriormente, comienza todo el proceso. Para que finalmente podamos ver el resultado en consola.

```python
createIslands()
print("Número de islas en el mapa:", countIslands())
```

---

# Problema de detección de objetos rojos dada una imagen

En este problema se requiere, identificar todos los objetos de color rojo de una imagen, dicha imagen contiene multiples objetos de distintos colores.
Para abordar este problema, es fundamental entender cómo una computadora puede representar colores, lo cual se logra a través de dos métodos específicos: RGB y HSV.
A continuación, examinaremos las distinciones entre los modelos de color RGB (Rojo, Verde, Azul) y HSV (Matiz, Saturación, Valor) y comprenderemos su funcionamiento de cada uno.

### RGB

El modelo de color RGB (Rojo, Verde, Azul) funciona mediante la combinación de tres colores primarios: rojo (Red), verde (Green) y azul (Blue). Cada uno de estos colores primarios se representa mediante un valor numérico que va desde 0 hasta 255. La combinación de estos tres colores en diferentes proporciones permite representar una amplia gama de colores.
En el sistema RGB, se crea un color específico ajustando la intensidad de cada uno de los tres colores primarios. Por ejemplo:

- **Color Rojo:** RGB(255, 0, 0) - Máxima intensidad de rojo, sin verde ni azul.
- **Color Verde:** RGB(0, 255, 0) - Máxima intensidad de verde, sin rojo ni azul.
- **Color Azul:** RGB(0, 0, 255) - Máxima intensidad de azul, sin rojo ni verde.

La mezcla de estos colores primarios en diferentes proporciones produce una amplia variedad de colores intermedios. La combinación de los tres colores en su máxima intensidad genera el color blanco, mientras que la ausencia completa de los tres colores resulta en negro.

Este modelo se utiliza ampliamente en dispositivos electrónicos, monitores y pantallas para representar colores mediante la emisión de luz de diferentes intensidades en cada uno de los componentes RGB. La representación de colores mediante el modelo RGB es fundamental en la mayoría de las imágenes digitales y medios visuales en la tecnología actual.

### HSV

El modelo de color HSV (Matiz, Saturación, Valor) se estructura en tres componentes principales que describen distintas características de un color:

1.  **Matiz (Hue):** Representa la tonalidad del color y se mide en grados en una escala circular (generalmente de 0 a 360°). En esta escala, los 0° y 360° corresponden al rojo, 120° al verde y 240° al azul, formando un espectro completo de colores.
2.  **Saturación (Saturation):** Indica la pureza o intensidad del color y se mide en porcentaje. A 0% de saturación, el color es completamente desaturado (gris), y a 100% de saturación, el color es lo más vibrante posible.
3.  **Valor (Value):** Controla la luminosidad o brillo del color, también en porcentaje. Un valor de 0% resulta en negro, independientemente de la saturación o matiz, mientras que un valor de 100% da como resultado la máxima luminosidad del color.

La representación polar del HSV facilita la manipulación intuitiva de colores, ya que los ajustes en cada uno de los componentes no afectan linealmente a otros, a diferencia del modelo RGB. Por ejemplo, cambiar el matiz en HSV altera el tipo de color sin afectar la luminosidad o saturación, lo que lo hace útil en aplicaciones como el ajuste de colores en diseño gráfico y procesamiento de imágenes. Este modelo es considerado más perceptualmente uniforme que el RGB, lo que significa que los cambios en los valores de los componentes HSV son más perceptualmente consistentes para el ojo humano.

Ahora que hemos profundizado en la comprensión de estos dos modelos de representación de colores, resulta evidente que la manipulación de colores se simplifica considerablemente al emplear el modelo HSV. Con este enfoque, podemos seleccionar con mayor facilidad colores específicos, lo que nos permite abordar de manera efectiva el desafío de detectar objetos rojos en una imagen mediante la utilización de la gama de colores en el espacio HSV.

Lo primero que debemos hacer, será instalar la librería de OpenCV como se muestra a continuación:

```
pip install opencv-python
```

ó bien,

```
pip3 install opencv-python
```

Ahora si pasamos a importar la librería y a acceder a la imagen la cual contendrá los objetos de color rojo.

```python
import cv2 as cv
img = cv.imread("ruta_de_la_imagen/imagen.jpg")
```

Posteriormente, definimos el intervalo de colores en el espacio HSV para la tonalidad roja. Esto implica establecer un umbral superior y un umbral inferior que delimitan la gama de colores rojos considerados para la detección de objetos. Cuanto más preciso sea el ajuste de estos umbrales, mejor será la capacidad de detección del color. En este contexto, el sistema HSV presenta dos espectros de color rojo, lo que se refleja en la asignación de dos valores tanto para el umbral alto como para el umbral bajo en las líneas de código subsiguientes.

```python
umbralBajo = (0,100,20)
umbralAlto = (4,255,255)

umbralBajo2 = (174,100,20)
umbralAlto2 = (179,255,255)
```

Normalmente, OpenCV trabaja las imagenes en RGB o BGR, para esto resolver esto debemos de cambiar el espectro de la imagen de BGR a HSV para poder trabajar con los colores correspondientes.

```python
img2 = cv.cvtColor(img, cv.COLOR_BGR2HSV)
```

Ahora, ya que cambiamos el modelo de color de la imagen a HSV crearemos unas **_máscaras_** que nos servirán de ayuda para que en la imagen únicamente se muestren los objetos que tienen el color rojo perteneciente a los los valores de los umbrales. Como tenemos 2 rangos de rojo, se crean 2 máscaras por separado para filtrar los objetos, así, después las combinamos con la función de _cv.add()_ y podemos tener una sola máscara pero con los dos rangos de rojo que se tiene en la escala de colores del HSV.
Una vez aplicadas estas mascaras, quedarán en una escala de blanco y negro, es decir, estarán binarizadas.

```python
mask2 = cv.inRange (img2, umbralBajo, umbralAlto)
mask3 = cv.inRange (img2, umbralBajo2, umbralAlto2)
mask = cv.add(mask2, mask3)
```

Ya que tenemos la máscara final, vamos a utilizar operaciones morfológicas que no es más que un conjunto de técnicas matemáticas, para este problema las utilizaremos con el fin de manipular la imagen y eliminar el ruido de ellas, es decir, falsos positivos o pixeles pequeños detectados como rojos.
Crearemos un elemento estructurado _(kernel)_ en forma de elipse con un tamaño de 3x3 píxeles y posteriormente aplicamos una operación de morfología de apertura a la máscara utilizando el kernel definido.
_La morfología de apertura es una operación que combina dos operaciones básicas: erosión seguida de dilatación. Ayuda a eliminar pequeños objetos, "agujeros" en los objetos y suaviza los contornos._

```python
kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, (3, 3))
imgLimpia = cv.morphologyEx(mask, cv.MORPH_OPEN, kernel)
```

Una vez hecho esto, tenemos la imagen, limpia por decirlo de alguna manera, lo que significa que ahora si ya quedan solamente los objetos de color rojo. Para contarlos vamos a detectar los contornos, para ello creamos una tupla.
En la función _findContours_ lo que ocurre es que encontraremos los contornos de los objetos contenidos en la imagen limpia, con _RETR_EXTERNAL_ simplemente tomaremos en cuenta los contornos exteriores, de esta manera ignora los contornos contenidos dentro del mismo objeto, finalmente, _CHAIN_APPROX_SIMPLE_ pinta puntos clave de los contornos, de esta manera ahorramos memoria y no pintamos todo el contorno de la figura.
Adicionalmente vemos que tenemos un _'\_'_ en la asignación, esto es para ignorar la jerarquía de los contornos, ya que, se utiliza RETR_EXTERNAL y la jerarquía no es necesaria para encontrar contornos externos
Se inicializa una variable en 0 que nos va ir ayudando a contar los objetos de la imagen.

```python
contornos, _ = cv.findContours(imgLimpia,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)
objetos = 0
```

Ahora creamos un ciclo para determinar todas las figuras que se detectaron en base a sus contornos y poder tener más información sobre ellas.
En el ciclo, se instancia una variable que considera el área del objeto detectado para determinar su tamaño. Se establece una condición para que solo se tengan en cuenta los objetos que tengan un número específico de píxeles, evitando así posibles falsos positivos. En caso de que el objeto cumpla con lo anterior, se genera un rectángulo de color rojo sobre la imagen original para encapsular e indicar el objeto de color rojo. Cuando ocurre esto incrementamos el contador de objetos detectados.

```python
for punto in contornos:
	area = cv.contourArea(punto)
	if(area > 15):
		x,y,w,h = cv.boundingRect(punto)
		cv.rectangle(img,(x,y),(x+w,y+h), (0,0,255),2)
		objetos = objetos + 1
```

Finalmente, creamos un rectángulo negro con la función _cv.rectangle_ en la parte superior izquierda de la imagen, a esta funcion le pasamos la imagen, las coordenadas, el tamaño del rectangulo, el color y el grosor, con un texto color blanco que indica la cantidad de objetos que fueron encontrados, este texto se crea con la función de _cv.putText()_ pasándole la imagen, el contador de objetos, las coordenadas donde se mostrará el resultado del contador de objetos, la fuente, el tamaño, el color y el grosor.

```python
objetos = str(objetos) +  " objetos rojos"
cv.rectangle(img, (0,0), (0 + 110, 0 + 10), (0,0,0), -1)
cv.putText(img, str(objetos), (0, y + int(10/2)), cv.FONT_HERSHEY_DUPLEX, 0.4,(255,255,255), 1)
cv.imshow ('Imagen limpia', imgLimpia)
cv.imshow ('máscara', mask)
cv.imshow ('original', img)
cv.waitKey ()
cv.destroyAllWindows()
```

---

# Problema de Josephus

La historia que sigue es una versión adaptada de lo que –supuestamente— sucedió durante el siglo I. Sí, el siglo uno. Suena raro, ¿no? Más aún: esa 5 historia dio origen a un problema clásico de la matemática/computación que sobrevivió el paso del tiempo. Se lo conoce con el nombre del “Problema de Josephus”, ya que se supone que fue Flavius Josephus, un historiador judío nacido en Jerusalén, quien describió la situación que vivieron él y 40 soldados que lo acompañaban.
En un momento determinado de la guerra judeo-romana, Josephus y su grupo cayeron en una emboscada y quedaron atrapados en una caverna rodeada de soldados enemigos. Después de debatir cómo proceder, optaron por suicidarse antes de ser capturados. Sin embargo, Josephus no estuvo de acuerdo con la propuesta y para que nadie tuviera que quitarse la vida, propuso el siguiente método:
“Sentémonos todos en un círculo. Alguno de nosotros empezará primero y matará a quien tenga sentado a la izquierda y así vamos a seguir hasta que –claramente— quedará nada más que uno solo de nosotros con vida. Ese será el único que tendrá que suicidarse”.
Supongamos que empieza el que está sentado en la posición número 1. Ese soldado matará al 2. Luego, el 3 matará al 4, el 5 al 6. . . y así siguiendo. Como usted advierte, llegará un momento en el que habrán muerto todos los que están sentados en las posiciones que llevan un número par. Pero cuando muera el último de ellos, el número 40 (a manos del 39), el 41 estará vivo aún y ahora, el que tiene sentado a la izquierda es el número 1 quien había empezado con los asesinatos.
De acuerdo con las reglas, el 41 matará al 1, el 3 matará al 5, etc. Creo que ahora está claro que van a morir todos hasta que quede solamente uno con vida.
Es aquí donde aparece una parte interesante de la historia de Josephus. En principio, habrían de morir todos los soldados que estaban con Josephus en la caverna, pero la diferencia es que quien quedara último tendría que suicidarse. . . Más aún: el sobreviviente tendría que quitarse la vida y no habría ningún otro integrante del grupo que estuviera vivo para verificar que lo hiciera.
Como usted se imagina, Josephus eligió un lugar particular del círculo y se sentó allí. El sabía que siguiendo las reglas escritas más arriba, él habría de quedar como único sobreviviente. Esperó que todos estuvieran muertos, y en lugar de suicidarse, salió de la caverna y se entregó al enemigo.

**Pregunta:** _¿En qué lugar se sentó Josephus?_

El problema es muy conocido en el mundo de la matemática y los programadores, y es por eso que hay muchísima literatura escrita sobre el tema, pero no hace falta saber nada particular para poder pensarlo. La versión que figura más arriba es solo una de las posibles variantes (la más sencilla) y si yo estuviera junto a usted, le sugeriría que no empiece con el caso de los 41 soldados, sino que intente con números más pequeños (de soldados) de manera tal de ver si le es posible intuir o imaginar una estrategia para determinar al ganador o sobreviviente a medida que va incrementando el número de soldados.
De la misma forma, una vez que hayamos resuelto el problema para 41 soldados, sería interesante pensar en una estrategia que permita deducir cuál será la posición ganadora en el caso general, es decir, independizarse del número 41 y encontrar alguna estrategia o fórmula que permita deducir el número que hay que elegir sin tener que recorrer todos los pasos intermedios.

Empezaremos para resolver el problema con casos sencillos, de esta manera, iremos incrementando el numero de supervivientes, de tal manera que podamos apreciar si este problema sigue un patrón o una secuencia.

Veamos que sucede para casos pequeños:

1. Si **_n_** es 1, entonces _S(1)_ es **1**.
2. Si **_n_** es 2, el superviviente 1 mata al 2 y sobrevive el 1, así que, **S(2) = 1**.
3. Si **_n_** es 3, entonces el superviviente 1 mata al 2 y el 3 mata al 1, tenemos que **S(3) = 3**.

Ahora, veremos una tabla, donde se han anotado casos hasta con 17 personas, determinando quien será el sobreviviente, en base a esto podremos analizar si existe algún patrón.

| n        | 1     | 2     | 3     | 4     | 5     | 6     | 7     | 8     | 9     | 10    | 11    | 12    | 13     | 14     | 15     | 16    | 17    |
| :------- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :---- | :---- |
| **S(n)** | **1** | **1** | **3** | **1** | **3** | **5** | **7** | **1** | **3** | **5** | **7** | **9** | **11** | **13** | **15** | **1** | **3** |

Analizando la tabla nos podemos dar cuenta de varias cosas. Primero que todo, todos los S(n) son números impares, por lo cual, colocarse en un número par llevaría a Josephus a la muerte si es que quiere salvarse.
Además, podemos ver el número 1 se repite varias veces, generalmente cuando **_n_** vale 1, 2, 4, 8, 16, es decir, que aparece cuando **_n_** es potencia de 2.

Para comprobar que no es buena idea colocarse en un número par. Basta con hacer una primer ronda, de la cantidad de supervivientes que sean, porque siempre el 1 matará al 2, el 3 al 4, el 5 al 6 y así sucesivamente.

Para comprobar la aparición del 1 en potencias de 2 veamos otro ejemplo. Suponiendo que el número **_n_** de personas en el círculo es par, como ya dijimos vemos siempre que en la primera ronda los pares mueren y le toca actuar de nuevo al número uno, en la segunda ronda, tenemos la mitad de personas en el círculo, es decir, **_n/2_** y si la cantidad de supervivientes vuelve a ser par estaremos en la misma situación inicial pero con la mitad de supervivientes y se volverá a cumplir que el numero de supervivientes en el circulo, será un numero que es potencia de 2 hasta que queda solamente una persona, que es la persona que inicio todo. Esto comprueba que **_S(n)=1_** si **_n_** es una potencia de 2.

Ahora para el caso general podemos decir que todo número se puede poner como una potencia de 2 más otro numero. Por ejemplo el **11 = 2^3+2^**. Bueno pues para resolver una parte hacemos lo siguiente: supongamos que el numero de soldados es **2^a^+m**. En la primera ronda hacemos 'm' turnos, los primeros 'M' impares matan a su compañero y después le toca el turno al número **2m+1** entonces, con esto en mente, podríamos decir que ese superviviente es el que sobrevive.

Para este problema, eran 41 personas, entonces podemos verlo de la siguiente manera:
**41 = 2^5+9^**, es decir, que **_'m'_** es 9 con lo que la posición del superviviente es la **19**.

Ahora pasemos al código que se generó para solucionar este problema, para ello, se tomó en cuenta todo lo previamente mencionado.
Primero tenemos una condicón por si se ingresa un 0 o un número menor en el numero de supervivientes, de ser así, informamos que ese número no es válido debiod a que el problema necesita tener más de 1 soldado.
En la parte del primer else, se coloca otra condición que es por si el numero es par y si el numero de soldados es una potencia de 2, si se cumple entonces la posición que se salvará será la numero 1 para este caso.

Si no se cumplen estas condiciones quiere decir que estamos frente a un caso donde el numero es impar o no es potencia de 2, es más general, es decir se resolverá con la formula _2m + 1_, finalmente imprimimos el valor de la posición que se salvará.

```python
import  math
def  kill(supervivientes):
	if supervivientes <= 0:
		print("Número de supervivientes no válido")
	else:
		aux = supervivientes
		aux = math.log2(supervivientes)
		if supervivientes % 2 == 0 and aux.is_integer():
			print("El superviviente en la posición 1 queda vivo")
		else:
			potencia = math.floor(math.log2(supervivientes))
			m = supervivientes - 2**potencia
			sobreviviente = 2 * m + 1
			print("El superviviente en la posición " + str(sobreviviente) + " queda vivo")

supervivientes  =  int(input("Introduce el número de supervivientes: "))
kill(supervivientes)
```

# Problema el papel de la heurística

La heurística comprende un conjunto de técnicas y métodos destinados a resolver problemas, siendo la palabra de origen griego εὑρίσκειν, que significa "hallar, inventar". Se considera la heurística como el arte de la invención por parte de los seres humanos, con la intención de desarrollar estrategias, métodos y criterios que faciliten la resolución de problemas mediante la creatividad, el pensamiento divergente o lateral.

La heurística se fundamenta en la experiencia personal del individuo y en la de otros para encontrar la solución más viable a un problema. En este contexto, se puede concebir la heurística como una teoría que estimula el pensamiento del individuo encargado de analizar todos los materiales recopilados durante una investigación. En este sentido, está relacionada con la toma de decisiones para resolver un problema, aunque no garantiza que la opción elegida sea la más idónea.

Como disciplina científica en su sentido más amplio, la heurística puede aplicarse a cualquier ciencia con el propósito de desarrollar medios, principios, reglas o estrategias que ayuden a encontrar la solución más eficaz y eficiente al problema analizado por el individuo.

Existen diversos procedimientos heurísticos que se clasifican en principios heurísticos, que ofrecen sugerencias para encontrar la solución ideal; reglas heurísticas, que indican los medios para resolver el problema; y estrategias heurísticas, que permiten organizar los materiales o recursos recopilados que contribuyen a la búsqueda de la solución del problema.

El término heurístico puede utilizarse como sustantivo y adjetivo. Como sustantivo, hace referencia a la ciencia o arte del descubrimiento, considerada como una disciplina digna de ser investigada. Como adjetivo, señala los principios, reglas y estrategias idóneas para encontrar la solución al problema.

Es relevante destacar que Albert Einstein utilizó el término heurística en su publicación sobre el efecto fotoeléctrico, titulada "Sobre un punto de vista heurístico concerniente a la producción y transformación de la luz", la cual le valió el Premio Nobel de Física en 1921.

Ahora veamos esto en programación, tenemos el siguiente código que aborda la resolución de cualquier laberinto mediante un enfoque recursivo. Esto lo hace de la siguiente manera

1. La representación del laberinto se generará mediante una matriz, donde las paredes se representarán con el número "1", los espacios vacíos o caminos con el número "0" y la salida del laberinto con el número '4'

2. El camino para resolver el laberinto se representa con el número '2'.

```python

laberinto  = [
[1,1,1,1,1,1,1,1,1],
[0,0,0,0,0,0,1,0,1],
[1,1,1,0,1,1,1,0,1],
[1,0,0,0,1,0,1,0,1],
[1,0,1,1,1,0,1,0,1],
[1,0,0,0,0,0,0,0,1],
[1,0,1,1,1,0,1,0,1],
[4,0,1,0,0,0,1,0,1],
[1,1,1,1,1,1,1,1,1],
]
```

Veamos la función recursiva denominada buscar(), que se encarga de resolver el laberinto. La función contiene condiciones para validar la posición (x, y) dentro de los límites del laberinto y establece casos base para determinar si se ha encontrado la salida _(4)._ Además, se asegura de no visitar paredes _(1)_ o celdas ya marcadas _(2)_.
En la tercera condición, se realiza una llamada recursiva para explorar los cuatro vecinos de la posición actual. Este enfoque recursivo facilita la búsqueda del camino de solución del laberinto, marcando las celdas con '0' o '1' según la configuración específica del laberinto. La ejecución de la función persiste hasta que se localiza la salida, identificada con el marcador "4".
Finalmente, se invoca la función utilizando las coordenadas iniciales (1, 0), y se muestra en pantalla el laberinto resuelto.

```py
def resolver(x, y):
	if x < 0 or y < 0 or x >= 9 or y >= 9:
		return
	if laberinto[x][y] == 4:
		return True
	elif laberinto[x][y] != 1 and laberinto[x][y] != 2:
		laberinto[x][y] = 2
		if resolver(x-1, y) or resolver(x+1,y) or resolver(x,y-1) or resolver(x, y+1):
			return True
		else:
			laberinto[x][y] = 0
resolver(1, 0)
for x in range(9):
	for y in range(9):
		print(f"{laberinto[x][y]} ", end="")
	print()
```

---

# Problema de las 3 ranas verdes y las 3 ranas marrones

El juego consiste en pasar las 3 ranas verdes a la derecha y las 3 ranas marrones a la izquierda. Las ranas pueden saltar a una piedra vacía que tengan delante, o saltar por encima de otra rana si en medio de ambas hay una piedra vacía.
Debemos tener en cuenta que, no es posible saltar por encima de más de 1 rana, es decir, veamos este ejemplo:

- RM3 | RM2 | RM1 | \_ | RV1 | RV2 | RV3

1. La rana verde 1 y 2, pueden saltar satisfactoriamente al espacio vacío, pero la rana verde 3, no puede realizar este salto. Lo mismo para las ranas del color marrón.

Ahora pasemos a la solución.

### Secuencia de percepción:

A continuación, se muestra en una tabla el análisis de todos los posibles estados o situaciones para el ejercicio de las ranas, las cuales podríamos realizar en este ejercicio para llegar al estado final o estado ideal.
Cabe destacar que la solución fue encontrada a base de prueba y error.

Durante la resolución de este problema encontraremos la siguiente notación:

- **RM:** Rana de color Marrón.
- **RV:** Rana de color Verde.

#### Espacio de estados

| Número de movimientos | Posición 1 | Posición 2 | Posición 3 | Posición 4 | Posición 5 | Posición 6 | Posición 7 |
| --------------------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| **0**                 | RM3        | RM2        | RM1        | -          | RV1        | RV2        | RV3        |
| **1**                 | RM3        | RM2        | -          | RM1        | RV1        | RV2        | RV3        |
| **2**                 | RM3        | RM2        | RV1        | RM1        | -          | RV2        | RV3        |
| **3**                 | RM3        | RM2        | RV1        | RM1        | RV2        | -          | RV3        |
| **4**                 | RM3        | RM2        | RV1        | -          | RV2        | RM1        | RV3        |
| **5**                 | RM3        | -          | RV1        | RM2        | RV2        | RM1        | RV3        |
| **6**                 | -          | RM3        | RV1        | RM2        | RV2        | RM1        | RV3        |
| **7**                 | RV1        | RM3        | -          | RM2        | RV2        | RM1        | RV3        |
| **8**                 | RV1        | RM3        | RV2        | RM2        | -          | RM1        | RV3        |
| **9**                 | RV1        | RM3        | RV2        | RM2        | RV3        | RM1        | -          |
| **10**                | RV1        | RM3        | RV2        | RM2        | RV3        | -          | RM1        |
| **11**                | RV1        | RM3        | RV2        | -          | RV3        | RM2        | RM1        |
| **12**                | RV1        | -          | RV2        | RM3        | RV3        | RM2        | RM1        |
| **13**                | RV1        | RV2        | -          | RM3        | RV3        | RM2        | RM1        |
| **14**                | RV1        | RV2        | RV3        | RM3        | -          | RM2        | RM1        |
| **15**                | RV1        | RV2        | RV3        | -          | RM3        | RM2        | RM1        |

### Medida de rendimiento:

La **_medida de rendimiento_** que se encontró fue de **15 saltos**, iniciando por saltar la rana color marrón 1, posteriormente, salta la rana color verde 1 al lugar donde estaba la rana marrón 1. Así, la rana verde 2 salta a la posición donde se encontraba la rana verde 1, la rana marrón 1 aprovecha el espacio dejado por la rana verde 2 y se coloca ahí. Ahora, la rana marrón 2 toma el espacio vacío y la rana marrón 3 toma el espacio precedente de la rana marrón 2. En este punto la rana verde 1 logra cruzar del otro lado tomando el lugar inicial de la rana marrón 3, la rana verde 2 aprovecha el lugar que dejo la rana verde 1 y salta ahí. La rana verde 3 finalmente salta al lugar vacío en la posición 5, seguido de esto la rana marrón ahora toma el lugar inicial de la rana verde 3. La rana marrón 2 logra tomar la posición 6, que es donde se encontraba inicialmente la rana verde 2. En este punto la rana marrón 3 toma la posición 4 y metemos a la rana verde 2 en la posición 2, donde inicialmente estaba la rana marrón 3.
Finalmente, la rana verde 3 salta a la posición 3 y la rana marrón a la posición 5. De esta manera, todas las ranas cruzaron de lado sin problema alguno.

# Problema de los 3 misioneros y los 3 caníbales

Tres misioneros se perdieron explorando una jungla. Separados de sus compañeros, sin alimento y sin radio, solo sabían que para llegar a su destino debían ir siempre hacia adelante. Los tres misioneros se detuvieron frente a un río que les bloqueaba el paso, preguntándose que podían hacer. De repente, aparecieron tres caníbales llevando un bote, pues también el-los querían cruzar el río. Ya anteriormente se habían encontrado grupos de misioneros y caníbales, y cada uno respetaba a los otros, pero sin confiaren ellos. Los caníbales se daban un festín con los misioneros cuando les superaban en número. Los tres caníbales deseaban ayudar a los misioneros a cruzar el río, pero su bote no podía llevar más de dos personas a la vez y los misioneros no querían que los caníbales les superaran en número. ¿Cómo puede resolverse el problema, sin que en ningún momento haya más caníbales que misioneros en cualquier orilla del río? recuerda que un misionero y un caníbal en una orilla del río más uno o dos caníbales en el bote al mismo lado, significa que los misioneros tendrán problemas.

Para este ejercicio se pide, encontrar la secuencia de percepción y la medida de rendimiento. Debemos tener en cuenta las reglas previamente ya mencionadas, no podemos dejar de un lado más caníbales porque estos podrían violentar a los monjes o misioneros.

Para este ejercicio solo fue cuestión de probar, aunque se encontró un patrón y es siempre llevar 1 monje y 1 caníbal en el bote.

### Secuencia de percepción:

A continuación, se muestra en una tabla el análisis de todos los posibles estados o situaciones para el ejercicio de monjes, las cuales podríamos realizar en este ejercicio para llegar al estado final o estado ideal.

Durante la resolución de este problema encontraremos la siguiente notación:

- **D:** Para lado derecho.
- **I:** Para lado Izquierdo.
- **I-D:** Cruza del lado izquierdo al lado derecho.
- **D-I:** Cruza del lado derecho al lado izquierdo.
- **mI:** Monjes en el lado izquierdo.
- **mD:** Monjes en el lado derecho.
- **cI:** Caníbales en el lado izquierdo.
- **cD:** Caníbales en el lado derecho.

#### Espacio de estados

|             Estado             |     Cruza Canibal solo      |       Cruza Monje Solo       |     Cruzan 2 Canibales      |       Cruzan 2 Monjes       |  Cruza 1 Monje y 1 Canibal  |
| :----------------------------: | :-------------------------: | :--------------------------: | :-------------------------: | :-------------------------: | :-------------------------: |
| **I (3 mI, 3 cI, 0 mD, 0 cD)** | I-D(3 mI, 2 cI, 0 mD, 1 cD) | I-D(2 mI, 3 cI, 1 mD, 0 cD)  | I-D(3 mI, 1 cI, 0 mD, 2 cD) |          problema           | I-D(2 mI, 2 cI, 1 mD, 1 cD) |
| **D (3 mI, 2 cI, 0 mD, 1 cD)** | D-I(3 mI, 3 cI, 0 mD, 0 cD) |          imposible           |          imposible          |          imposible          |          imposible          |
| **D (2 mI, 3 cI, 1 mD, 0 cD)** |          imposible          | D-I(3 mI, 3 cI, 0 mD, 0 cD)  |          imposible          |          imposible          |          imposible          |
| **D (3 mI, 1 cI, 0 mD, 2 cD)** | D-I(3 mI, 2 cI, 0 mD, 1 cD) |          imposible           | D-I(3 mI, 3 cI, 0 mD, 0 cD) |          imposible          |          imposible          |
| **I (3 mI, 2 cI, 0 mD, 1 cD)** |          problema           | I-D(2 mI, 2 cI, 1 mD, 1 mD)  | I-D(3 mI, 0 cI, 0 mD, 3 cD) |          problema           |          problema           |
| **D (3 mI, 0 cI, 0 mD, 3 cD)** | D-I(3 mI, 1 cI, 0 mD, 2 cD) |          imposible           | D-I(3 mI, 2 cI, 0 mD, 1 cD) |          imposible          |          imposible          |
| **D (2 mI, 2 cI, 1 mD, 1 cD)** |          problema           | D-I (3 mI, 2 cI, 0 mD, 1 cD) |          imposible          |          imposible          | D-I(3 mI, 3 cI, 0 mD, 0 cD) |
| **I (3 mI, 1 cI, 0 mD, 2 cD)** | I-D(3 mI, 2 cI, 0 mD, 1 cD) |           problema           |          imposible          | I-D(1 mI, 1 cI, 2 mD, 2 cD) |          problema           |
| **D (1 mI, 1 cI, 2 mD, 2 cD)** |          problema           |           problema           |          problema           | D-I(3 mI, 1 cI, 0 mD, 2 cD) | D-I(2 mI, 2 cI, 1 mD, 1 cD) |
| **I (2 mI, 2 cI, 1 mD, 1 cD)** |          problema           |           problema           |          problema           | I-D(0 mI, 2 cI, 3 mD, 1 cD) | I-D(1 mI, 1 cI, 2 mD, 2 cD) |
| **D (0 mI, 2 cI, 3 mD, 1 cD)** | D-I(0 mI, 3 cI, 3 mD, 0 cD) |           problema           |          imposible          | D-I(2 mI, 2 cI, 1 mD, 1 cD) |          problema           |
| **I (0 mI, 3 cI, 3 mD, 0 cD)** | I-D(0 mI, 2 cI, 3 mD, 1 cD) |          imposible           | I-D(0 mI, 1 cI, 3 mD, 2 cD) |          imposible          |          imposible          |
| **D (0 mI, 1 cI, 3 mD, 2 cD)** | D-I(0 mI, 2 cI, 3 mD, 1 cD) | D-I(1 mI, 1 cI, 2 mD, 2 cD)  | D-I(0 mI, 3 cI, 3 mD, 0 cD) |          problema           |          problema           |
| **I (0 mI, 2 cI, 3 mD, 1 cD)** | I-D(0 mI, 1 cI, 3 mD, 2 cD) |          imposible           | I-D(0 mI, 0 cI, 3 mD, 3 cD) |          imposible          |          imposible          |
| **I (1 mI, 1 cI, 2 mD, 2 cD)** |          problema           | I-D(0 mI, 1 cI, 3 mD, 2 cD)  |          imposible          |          imposible          | I-D(0 mI, 0 cI, 3 mD, 3 cD) |
| **D (0 mI, 0 cI, 3 mD, 3 cD)** | D-I(0 mI, 1 cI, 3 mD, 2 cD) |           problema           | D-I(0 mI, 2 cI, 3 mD, 1 cD) |          problema           | D-I(1 mI, 1 cI, 2 mD, 2 cD) |
| **I (0 mI, 1 cI, 3 mD, 2 cD)** | I-D(0 mI, 0 cI, 3 mD, 3 cD) |          imposible           |          imposible          |          imposible          |          imposible          |

### Medida de rendimiento:

La **_medida de rendimiento_** que yo encontré fue de **11 pasos**, iniciando por cruzar un monje y un caníbal al lado derecho (2m, 2c, 1m, 1c), el monje regresa solo al lado izquierdo (3m, 2c, 0m, 1c), luego cruzan dos caníbales del lado izquierdo al lado derecho (3m, 0c, 0m, 3c), ahora cruza un caníbal solo del lado derecho al lado izquierdo (3m, 1c, 0m, 2c), cruzamos dos monjes del lado izquierdo al lado derecho (1m, 1c, 2m, 2c), luego cruzan 1 monje y un caníbal del lado derecho al lado izquierdo (2m, 2c, 1m , 1c), ahora cruzan dos monjes del lado izquierdo al lado derecho y ya tenemos 3 monjes del lado derecho con un caníbal y del lado izquierdo 2 caníbales solamente. Después de esto, el caníbal del lado derecho cruza al lado izquierdo (0m, 3c, 3m, 0c), y cruzan 2 caníbales del lado izquierdo al lado derecho (0m, 1c, 3m, 2c), finalmente el caníbal del lado derecho regresa al lado izquierdo por el tercer caníbal y juntos regresan al lado derecho. De esta manera, llegamos de la manera más optima al estado final.

---

# Generación de Dataset de rostros

Un conjunto de datos (conocido también por el anglicismo dataset, comúnmente utilizado en algunos países hispanohablantes) es una colección de datos habitualmente tabulada. En el caso de datos tabulados, un conjunto de datos contiene los valores para cada una de las variables organizadas como columnas, como por ejemplo la altura y el peso de un objeto, que corresponden a cada miembro delconjunto de datos, que están organizados en filas. Cada uno de estos valores se conoce con el nombre de dato. El conjunto de datos también puede consistir en una colección de documentos o de archivos.

Para esta actividad se requirió un total de 5 personas, para que pudieramos generar el dataset, en este caso fueron 200 fotos por persona.
Dichas fotos se tomaron con un programa previamente visto en clase que a continuación se muestra:

```python
import numpy as np
import cv2 as cv
import math

cap = cv.VideoCapture(0)
i = 0

while True:
	i = i + 1
	ret, frame = cap.read()
	frame = cv.rectangle(frame, (220, 50), (550, 400), (0, 255, 0), 5)
	frame2 = frame[40:400, 210:550]
	cv.imwrite('ruta_para_guardar_las_imagenes\\' + str(i) + '.jpg', frame2)
	cv.imshow("frame", frame)
	cv.imshow("dataset", frame2)
	k = cv.waitKey(1)
	if  k == 27:
	break

cap.release()
cv.destroyAllWindows()
```

Este programa no hace más que acceder a la cámara del sistema y mostrarla, después en una ventana aparte, muestra la misma cámara pero con un recorte que va más enfocado a nuestra cara, esa ventana es dónde se muestra cómo quedará la foto. Estas fotos se toman consecutivamente una vez arranca el programa y utilizamos un contador para que pueda darle un nombre diferente a cada foto, en este caso son fotos con nombres numerados.

Para generar el dataset, veamos lo siguiente.

### Eigenfaces

Un Eigenface (en español cara propia) es el nombre dado a un conjunto de vectores propios cuando se utiliza en el problema de visión artificial del reconocimiento de rostros humanos. Sirovich y Kirby desarrollaron el enfoque de usar caras propias para el reconocimiento y lo usaron Matthew Turk y Alex Pentland en la clasificación de caras. Los vectores propios se derivan de la matriz de covarianza de la distribución de probabilidad sobre el espacio vectorial de alta dimensión de imágenes de rostros. Las caras propias forman un conjunto base de todas las imágenes utilizadas para construir la matriz de covarianza. Esto produce una reducción de la dimensión al permitir que el conjunto más pequeño de imágenes base represente las imágenes de entrenamiento originales. La clasificación se puede lograr comparando cómo se representan las caras por el conjunto base.

### Generación

Se puede generar un conjunto de caras propias mediante la realización de un proceso matemático llamado análisis de componentes principales (PCA) en un gran conjunto de imágenes que representan diferentes rostros humanos. De manera informal, las caras propias pueden considerarse un conjunto de "ingredientes faciales estandarizados", derivados del análisis estadístico de muchas imágenes de rostros. Cualquier rostro humano puede considerarse una combinación de estos rostros estándar. Por ejemplo, la cara de uno podría estar compuesta por la cara promedio más el 10 % de la cara propia 1, el 55 % de la cara propia 2 e incluso el −3 % de la cara propia 3. Sorprendentemente, no se necesitan muchas caras propias combinadas para lograr una aproximación justa de la mayoría de las caras. Además, debido a que la cara de una persona no se registra mediante una fotografía digital, sino simplemente como una lista de valores (un valor para cada cara propia en la base de datos utilizada), se ocupa mucho menos espacio para la cara de cada persona.
Las caras propias que se crean aparecerán como áreas claras y oscuras que se organizan en un patrón específico. Este patrón es cómo se seleccionan las diferentes características de una cara para evaluarlas y puntuarlas. Habrá un patrón para evaluar la simetría, si hay algún estilo de vello facial, dónde está la línea del cabello o una evaluación del tamaño de la nariz o la boca. Otras caras propias tienen patrones que son menos fáciles de identificar, y la imagen de la cara propia puede parecerse muy poco a una cara.
La técnica utilizada en la creación de caras propias y su uso para el reconocimiento también se utiliza fuera del reconocimiento facial: reconocimiento de escritura a mano, lectura de labios, reconocimiento de voz, lenguaje de señas /interpretación de gestos con las manos y análisis de imágenes médicas. Por lo tanto, algunos no usan el término "eigenface", sino que prefieren usar 'eigenimage'.
Ahora bien, comenzamos por instalar las librerías:

```
pip install opencv-python
pip install numpy
```

ó

```
pip3 install opencv-python
pip3 install numpy
```

Una vez hecho comenzamos importándolas:

```python
import cv2 as  cv
import numpy as  np
import  os
```

seguido de esto, pasamos el directorio para el dataset:

```python
dataSet ='C:\\Users\\Edani\\OneDrive\\Documentos\\IA\\DatasetRostros'
faces  =  os.listdir(dataSet)
print(faces)
```

Ahora lo que haremos, será recorrer cada una de estas carpetas que contienen los rostros de las diferentes personas, para poder sacar cada foto y la agregamos a una lista donde esatarán todas las fotos, aquí tenemos una variable labels y un label, la variable labels es una lista que guardara el numero de cada persona y la variable label es simplemente un contador.
Al final solo corroboramos cuantas fotos fueron para cada label.

```python
labels = []
facesData = []
label = 0
for face in faces:
	facePath = dataSet+'\\'+face
	for faceName in os.listdir(facePath):
		labels.append(label)
		facesData.append(cv.imread(facePath+'\\'+faceName,0))
	label = label + 1
for c in range(label):
print(np.count_nonzero(np.array(labels) == c))
```

Ahora, procederemos a generar el XML con la técnica de **_eigenfaces_** mediante el siguiente código.

```python
faceRecognizer  =  cv.face.EigenFaceRecognizer_create()
faceRecognizer.train(facesData, np.array(labels))
faceRecognizer.write('edgareigenface.xml')
```

Como podemos ver, creamos primero una instancia de la técica y posteriormente la entrenamos pasándole los labels y los rostros para que los asocie.
Finalmente, para probar esto, lo haremos mediante el siguiente código:

```python
import cv2 as  cv
import  os

faceRecognizer  =  cv.face.EigenFaceRecognizer_create()
faceRecognizer.read('edgareigenface.xml')

cap  =  cv.VideoCapture(0)

rostro  = cv.CascadeClassifier('C:\\Users\\Edani\\OneDrive\\Documentos\\IA\\Jupyter\\Introduccion-OpenCV\\Video\\haarcascade_frontalface_alt.xml')

while  True:
	ret, frame  =  cap.read()
	if  ret  ==  False: break
	gray  =  cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
	cpGray  =  gray.copy()
	rostros  =  rostro.detectMultiScale(gray, 1.3, 3)
	for(x, y, w, h) in  rostros:
		frame2  =  cpGray[y:y+h, x:x+w]
		frame2  =  cv.resize(frame2, (340,360), interpolation=cv.INTER_CUBIC)
		result  =  faceRecognizer.predict(frame2)
		cv.putText(frame, '{}'.format(result), (x,y-20), 1,3.3, (255,255,0), 1, cv.LINE_AA)
	cv.imshow('frame', frame)
	k  =  cv.waitKey(1)
	if  k  ==  27:
		break
cap.release()
cv.destroyAllWindows()
```

Este programa no hace más que leer el XML que entrenamos y apoyarse del haarcascade_frontalface para poder reconocer caras frontales y determinar mediante acceso a la cámara que persona (hablando de su label) se encuentra frente a la cámara. Muestra arriba de la cabeza de la persona, el número de label y otro número con muchos dígitos.
